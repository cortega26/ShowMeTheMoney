{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import datetime\n",
    "import statistics\n",
    "import ssl  # we need to import this library and tweak one setting due to fact we use HTTPS certificate(s)\n",
    "\n",
    "filepath = \"https://www.cryptodatadownload.com/cdd/Binance_LTCUSDT_minute.csv\"\n",
    "\n",
    "ssl._create_default_https_context = ssl._create_unverified_context\n",
    "\n",
    "# Now we want to create a dataframe and use Pandas' to_csv function to read in our file\n",
    "data = pd.read_csv(filepath, skiprows=1)  # we use skiprows parameter because first row contains our web address\n",
    "\n",
    "# Finally we convert the dataframe into an array in order to easily iterate thru it\n",
    "data = np.array(data)\n",
    "\n",
    "\n",
    "# LABELS\n",
    "# bos: base order size\n",
    "# fsos: first safety order size\n",
    "# csos: current safety order size\n",
    "# sovs: safety order volume scale\n",
    "# inv: amount invested + locked safety trade\n",
    "# stc: safety trades count\n",
    "# stu: safety trades used\n",
    "# tp: target profit %\n",
    "# ip: initial price\n",
    "# pd: price deviation to open safety orders (% from initial order)\n",
    "# fp: Total profit for the Backtest Strategy\n",
    "\n",
    "def Backtest(tp,bos,fsos,sovs,pd,stc,tdays):\n",
    "    ip = 0 \n",
    "    fp = 0\n",
    "    stu = 0\n",
    "    tm = 0\n",
    "    count = 0\n",
    "    tmins = tdays * 60 * 24\n",
    "    volatility = []\n",
    "    for i in reversed(data):\n",
    "        count += 1\n",
    "        if float(i[5]) > 0 and float(i[6]) > 0 and count >= len(data) - tmins:\n",
    "            low = float(i[5])  #lowest price in the interval\n",
    "            high = float(i[6]) #highest price in the interval\n",
    "            if ip == 0: #first order\n",
    "                ip = (low + high) / 2\n",
    "                inv = bos\n",
    "                dca = ip\n",
    "                crypto = bos / ip\n",
    "                csos = fsos\n",
    "                date1 = datetime.date(int(i[1][0:4]),int(i[1][5:7]),int(i[1][8:10]))\n",
    "                time1 = datetime.time(int(i[1][11:13]),int(i[1][14:16]),int(i[1][17:19]))\n",
    "                datetime1 = datetime.datetime.combine(date1,time1)\n",
    "                datetime3 = datetime1\n",
    "            elif high >= dca * ((100 + tp) / 100): #Condition to take profits\n",
    "                fp += tp/100 * inv\n",
    "                dca *= (100 + tp) / 100\n",
    "                inv = bos\n",
    "                crypto = bos / dca\n",
    "                stu = 0\n",
    "                ip = dca\n",
    "                csos = fsos\n",
    "            elif low <= ip * ((100 - pd * (1 + stu)) / 100) and stu < stc: #Condition to activate safety trade\n",
    "                crypto += csos / (ip * ((100 - pd * (1 + stu)) / 100))\n",
    "                inv += csos\n",
    "                csos *= sovs\n",
    "                stu += 1\n",
    "                dca = inv / crypto\n",
    "            else: #in any other case do nothing\n",
    "                pass\n",
    "            date2 = datetime.date(int(i[1][0:4]),int(i[1][5:7]),int(i[1][8:10]))\n",
    "            time2 = datetime.time(int(i[1][11:13]),int(i[1][14:16]),int(i[1][17:19]))\n",
    "            datetime2 = datetime.datetime.combine(date2,time2)\n",
    "            tm += inv\n",
    "            elapsed2 = datetime2 - datetime1\n",
    "            if elapsed2.total_seconds() % 86400 == 0:\n",
    "                low2 = float(i[5])\n",
    "                high2 = float(i[6])\n",
    "                #print(time2)\n",
    "                #print(time2-time1)\n",
    "            elif int((elapsed2.total_seconds()) + 60) % 86400 == 0:\n",
    "                diff = round((high2 - low2) / high2 * 100, 2)\n",
    "                volatility.append(diff)\n",
    "            else:\n",
    "                if float(i[5]) < low2:\n",
    "                    low2 = float(i[5])\n",
    "                elif float(i[6]) > high2:\n",
    "                    high2 = float(i[5])\n",
    "        else:\n",
    "            pass\n",
    "            #print(\"Missing values or equal to zero. Program terminated.\")\n",
    "            #break\n",
    "            \n",
    "            \n",
    "    elapsed = datetime2 - datetime1\n",
    "    elapsed_float = elapsed.total_seconds() / 86400\n",
    "    #print(elapsed_float)\n",
    "    print(\"Starting date:\",datetime1)\n",
    "    print(\"Latest date:\",datetime2)\n",
    "    print(\"Days of Backtesting:\",elapsed)\n",
    "    print(\"Safe Trades Used in current deal:\",stu)\n",
    "    print(\"Money currently invested:\",round(inv,2))\n",
    "    print(\"Current DCA:\",round(dca,2))\n",
    "    print(\"Total profit for the period:\",round(fp,2))\n",
    "    print(\"Aprox. earnings/day:\",round(fp/elapsed_float,2))\n",
    "    print(\"Average money invested:\",round(tm/(elapsed_float*24*60),2))\n",
    "    print(\"Daily profitability vs. Average money invested: \" + str(round((24 * 60 * 100 * fp / tm),2)) + \"%\")\n",
    "    #print(volatility)\n",
    "    print(\"Mean of daily volatility:\", str(round(statistics.mean(volatility),2)) + \"%\")\n",
    "    print(\"\")\n",
    "    \n",
    "def automate():\n",
    "    tp=0\n",
    "    for i in range(1,51):\n",
    "        tp = float(i/10)\n",
    "        print(\"Take profit:\",str(tp)+\"%\")\n",
    "        Backtest(tp,10,20,1.05,2,30)\n",
    "\n",
    "Backtest(2,10,10,1.05,2,30,30)\n",
    "\n",
    "    \n",
    "#automate()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
